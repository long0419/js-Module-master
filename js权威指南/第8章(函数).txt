1.js的函数可以嵌套在其他函数中定义，这样他就可以访问它们被定义时所处的作用域中的任何变量。这意味着js函数构成了一个【闭包】，这是个很强有力的能力。

2.js可以把函数赋值给变量，或者作为参数传递给其他函数。因为函数就是对象，所以可以给他们设置属性，甚至调用他们的方法。

3.嵌套函数
    嵌套函数它们可以访问嵌套他们的函数的参数和变量。

4.函数调用：
        this是一个关键字，不是变量，也不是属性名。js语法是不允许给this赋值的。和变量不同，关键字this没有作用域的限制，嵌套的函数不会从调用他的函数中继承this 。
    如果嵌套函数作为方法调用，其this的值指向调用它的对象。如果嵌套函数作为函数调用,其this值不是全局对象(非严格模式下)就是undefined(严格模式下)。很多人误以
    为调用嵌套函数时this会只想调用外层函数的上下文。【如果你想访问这个外部函数的this值，需要将this的值保存在一个变量里，这个变量和内部函数都同在一个作用域内。】
    通常使用self来保存this。

5.函数的调用
        JS函数也是对象，和其他的js对象没有两样，函数对象也可以包含方法。其中两个方法call()和apply()可以用来间接的调用函数。两个方法都允许显式指定调用所需的this值，
    也就是说，任何函数可以作为任何对象的方法来调用，哪怕这个函数不是哪个对象的方法。call()方法使用他自由的实参列表作为函数的实参，apply（）方法则要求以数组的形式
    传入参数。

6.js函数定义并未指定函数形参的类型，函数调用也未对传入的实参值做任何类型检查。实际上，JS函数调用甚至不检查传入形参的个数。
        可选形参：
            当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为undefined值。

        可变长的实参列表：
            当调用函数的时候实参个数超过函数定义时的形参个数时，没有办法直接获得未命名值的引用。在函数体内，标识符arguments是指向实参对象的引用，实参对象是一个类数
         组对象，这样可以通过数字下标就能访问传入函数的实参值，而不用非要通过名字来得到实参。
            实参对象有一个重要的用处，就是让函数可以操作任意数量的实参。（注意例子）
            ES5中移除了实参对象的这个特殊特性。在严格模式下还有一点不同，飞严格模式下，函数里面的arguments仅仅是一个标识符，在严格模式中，它变成了一个保留字。

7.匿名的函数表达式：
            假设你写了一段JS 模块代码，这段代码将要用在不同的js程序中。和大多数代码一样，假定这段代码定义了一个用以存储中间计算结果的变量。这样问题就来了，当模块代码放
        到不同的程序中运行时，你无法得知这个变量是否已经创建了，如果已经存在这个变量，那么将会和代码发生冲突。可以直接定义个匿名函数，并在单个表达式中调用它：
            (function(){

            }());

            这里定义的函数会立即调用。如果要使用的话，可以有返回值，然后调用里面的方法。


8.闭包
            JS采用词法作用域，也就是说，函数的执行依赖于变量作用域，这个作用域是在函数定义时决定的，而不是在函数调用时决定的。为了实现这种词法作用域，JS函数对象的内部状态
        不仅包含函数的代码逻辑，还必须引用当前的作用域链。
            举例：https://github.com/lin-xin/blog/issues/8


9.函数的属性、方法和构造函数
            length属性：在函数体里面，arguments.length表示传入函数的实参的个数。  ： arguments.length （实际传入的实参个数） 、arguments.callee.length（期望传入的实参个数）
            prototype属性：   每个函数都包含一个prototype属性，这个属性是只想一个对象的引用，这个对象称为“原型对象”。每个函数都包含不同的原型对象。当讲函数用作构造函数的是话，新创建的对象会从原型对象上继承属性。
            call 和 apply 方法 ： 可以将call（）和apply（）看作某个对象的方法。通过调用方法的形式来间接调用函数。具体参考第三章记录。
            bind方法：ES5新增的方法，主要作用是将函数绑定至某个对象。当在函数f()上调用bind（）方法并传入一个对象o作为参数，这个方法将返回一个新的函数。调用新的函数将会把原始的函数f()当做o的方法来调用。传入新函数的任何
        实参都将传入原始函数。 参考：http://blog.51cto.com/rangercyh/1615809
            function f(y){ return this.x + y } //这个是带绑定的函数
            var o = { x : 1 } ;
            var g = f.bind(o) ;
            g(2) ;

            ES5中的bind()方法不积极是将函数绑定至一个对象，它还附带一些其他的应用：除了第一个实参之外，传入bind()的实参也会绑定至this，这种附带的应用是一种常见的函数式编程技术。


